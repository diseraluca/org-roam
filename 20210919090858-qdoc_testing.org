:PROPERTIES:
:ID:       5a7cbc56-7130-4127-a4d1-c7d9ce7f9b59
:END:
#+title:Thoughts about QDOC-Testing

+ We have a desire to be able to talk about what we expect parts of QDoc to do.
+ We have a desire to be able to feel more secure about doing small-scale or mid-scale refactoring.
+ We have a desire to be able to have a framework that can help us when developing new parts of the system.

# How to think about QDoc for testing?

+ <<UntiedFromTheCode>> We want to avoid tying ourselves to the code too much
+ We need to be able to observe properties that depend on QDoc behavior
+ We want to be able to identify subsystems and their relation
+ We want to be able to identify boundaries between the subsystems

To be able to respect [[UntiedFromTheCode]], we need a way to talk or
observe QDoc that is not based on the way the code is implemented.

To do this, we need to talk about QDoc's behavior, from an observer
point of view.

The obvious choice is the user, whose point of view is removed from
the code implementation completely while posing as an observer of
QDoc's behavior.

## Key parts of QDoc from a user point of view

+ To use QDoc a user needs to provide:
  * A /qdocconf/ file that defines a project
+ Furthermore, to have a meaningful interaction with QDoc, a user needs to provide:
  * One or more files containing QDoc block-comments

+ Given the above things, the user uses QDoc to obtain a version of
  its documentation generated in a specific way.

Given the above, we can define the user interaction with QDoc similarly to the one with a compiler.
The user provides a series of sources to QDoc, such as to produce a compiled artifact from them.

#+begin_src mermaid :file assets/images/autogenerated/user_qdoc.png
flowchart LR
  subgraph Project
    Configuration
    SF[Source Files]
  end
  Project --> QDoc
  QDoc --> GH[Generated Output]
#+end_src

#+RESULTS:
[[file:assets/images/autogenerated/user_qdoc.png]]

We identify the following parts as central to QDoc's user experience:

+ The /Project/
  - The /Configuration/
  - The /Source Files/
+ The /Generated Output/

Furthermore we identify QDoc as putting into a relation the /Project/,
and its components, to the /Generated Output/ as a *step* that takes
the former as input to generate the latter.

+ We can use this initial idea to build one possible view of QDoc that
  is not tied to the code, but to its behavior as a black box, and use
  it to guide us when building a test suite.

## Granularizing QDoc end-to-end tests

Using the above graph as a base, we can think of QDoc as a black box
procedure consuming some input and producing some output.

From a testing perspective, this is covered by the current end-to-end
infrastructure. Together with the end-to-end infrastructure, a
unit-test infrastructure was considered, but was discarded for a lack
of resources.

As QDoc code has many moving pieces which are tighly coupled and full
of dependency, it was considered difficult to build meaningful unit
tests.

The end-to-end tests, instead, were possible as they didn't require
any coupling to the code.

Indeed, the only part required for an end-to-end test are those
outlined above.

Compared to unit-tests, we argue that the introduced end-to-end tests
were simple to implement as they provided the following
characteristics:

  + A well defined input which the implementer knew how to produce with one or more desired *properties*.
  + A well derined output whose *properties* are *observable* and *comparable*.
  + A well defined *step* to map an input to an ouput.

We argue that, as long as we can reproduce those same condition at a
different granular level, we can build a test suite that is mentally
abstracted away from the code, hiding its intricacies.

+ Setting up QDoc tests as a series of abstract end-to-end tests over a unit part of QDoc should allow us to build a test suite whose behavior is well defined and whose resistant to code changes, as it does not depend on the specific implementation that is provided.

  * The test implementation itself will hide the complexety of the
    underlying code implementation. Refactoring the code interfaces
    will require a refactoring of implementation only, keeping the
    behavior expressed behavior intact.

### BUilding a framework to talk about smaller QDoc ends

We say that a *step* is a black-box procedure consuming an *input source* and producing an *output source*.

We say that an end-to-end test has a domain called a *step*.

A test suite for a *step* X, is a collection of all end-to-end tests that have a domain of X.

#+begin_src mermaid :file assets/images/autogenerated/configuration.png
flowchart LR
  subgraph ConfigurationStep[Configuration Step]
    subgraph ParseStep[Parse Step]
    end
  end
  CS[\Configuratdion Source\] --> ConfigurationStep
  CS --> ParseStep
  ConfigurationStep --> Configuration[/Configuration/]
#+end_src

#+RESULTS:
[[file:assets/images/autogenerated/configuration.png]]
