#+title: EaC:Scanners
#+roam_tags: EaC compilers books lexer lexing scanning scanner finite-automata nondeterministic-finite-automata regex nondeterministic-finite-automata deterministic-finite-automata thompson-construction subset-construction hopcroft-algorithm table-driven-scanners direct-coded-scanners hand-coded-scanners kleene-construction brzozowski-algorithm 
#+roam_source: [[https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0][Engineering A Compiler]]


+ Aggregates sequences of characters into a sequence of words that are /parts of speech/ in the language.
  * First stage the compiler does to understand the input program.
  * Only pass in the compiler which touches all characters.
  * While scanners can be generated, most compilers use hand-crafter ones to improve performance.
    
+ Syntactic category :: A classification of words according to their grammatical usage.
+ Microsyntax :: The lexical structure of a language.
  
The scanner reads an input streams and produces a stream of words labeled by their syntactic category.
To achieve this construction, the scanner applies the lexical rules of the language, its /microsyntax/.

    * Most programming languages have a simple microsyntax where characters are
      collected into words and blanks and punctuation marks signal the
      separation between words.
    * Most programming languages have a series of 'reserved keywords' which
      match the rule for an identifier. The scanner categorizes them into their
      own category by either using a lookup table or by encoding this
      distinction into the mycrosyntax of the language.

+ Scanners can be implemented to require \(\bm{O}(1)\) time per character, and, hence, \(\bm{O}(n)\) time proportional to the characters in the input stream.

*** Recognizing Words

    A recognizer can be seen, mathematically, as a finite automata.

    + Finite Automaton :: A formalism for recognizers that has a finite set of states, an alphabet, a transition function, a start state and one or more accepting states.
      + Transition Diagram :: Visualization of a finite automata.

      A finite automaton is a five tuple \(\left(S, \Sigma, \delta, s_0, S_A \right)\) where
      
      * \(S\) is the finite set of states in the recognizer, along with an error state \(S_e\).
      * \(\Sigma\) is the finite alphabet used by the recognizer. Typically, \(\Sigma\) is the union of the edge labels in the transition diagram.
      * \(\delta(s, c)\) is the recognizer's transition function. It maps each
        state \(s\in S\) and each character \(c \in \Sigma\) into some next
        state. In state \(s_i\) with input character \(c\), the finite automata
        takes the transition \(s_i \overset{c}{\rightarrow} \delta(s_i, c)\).
      * \(S_A\) is the set of accepting states, \(S_A \subseteq S\).
        
      For example, we can describe a recognizer for the words /while/, /not/ and /now/, as follows:

      #+name: while_new_not_finite_automaton
      #+caption: A finite automaton recognizing the words while, not and now.
      #+begin_latex
        \begin{align*}
          S &= \left{ s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_10, s_e \right} \\[5pt]
          \Sigma &= \left{ e, h, i, l, n, o, t, w \right} \\[5pt]
          \delta &= \begin{Bmatrix}s_0 \overset{n}{\rightarrow}s_1&s_0 \overset{w}{\rightarrow}s_6&s_1 \overset{e}{\rightarrow}s_2&s_1\overset{o}{\rightarrow}s_4&s_2 \overset{w}{\rightarrow}s_3\\s_4 \overset{t}{\rightarrow}s_5&s_6 \overset{h}{\rightarrow}s_7&s_7 \overset{i}{\rightarrow}s_8&s_8\overset{l}{\rightarrow}s_9&s_9 \overset{e}{\rightarrow}s_{10}\end{Bmatrix} \\[5pt]
          s_0 &= s_0 \\[5pt]
          S_A &= \left{ s_3, s_5, s_{10} \right}
        \end{align*}
      #+end_latex

     
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_while_new_not.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|n| s_1((s_1))
          s_0 -->|w| s_6((s_6))

          s_1 -->|e| s_2((s_2))
          s_1 -->|o| s_4((s_4))

          s_2 -->|w| s_3[[s_3]]

          s_4 -->|t| s_5[[s_5]]
 
          s_6 -->|h| s_7((s_7))
          s_7 -->|i| s_8((s_8))
          s_8 -->|l| s_9((s_9))
          s_9 -->|e| s_10[[ s_10 ]]
      #+end_src

      #+caption: Transition Diagram for [[while_new_not_finite_automaton]].
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_while_new_not.png]]

      Implicitly, all other combination of states, \(s_i\) and character, \(c\) we define the transition to the error state \(\delta(s_i, c) = s_e\).
      
      An FA accepts a string if and only if the sequence of characters leave the FA in an accepting state when the whole input is consumed.
      Formally, if the string \(x\) is composed of the characters \(x_1x_2x_3\ldotsx_n\), then the FA \(\left(S, \Sigma, \delta, s_0, S_A \right)\) accepts \(x\) iff \(\delta(\delta(\ldots\delta(\delta(\delta(s_0, x_1), x_2, x_3)\ldots,x_{n_1}), x_n) \in S_A\).

      The other possibilities is that the FA encounters an error. That is, it transitions to the error state or it consumes the input without finishing in an accepting state.

****** Recognizing unsigned numbers

       We can build a recognizer for an unsigned number, that is either 0 or a sequence of digits not starting with zero, as follows:

       
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_3[[s_3]]
          s_3 -->|0..9| s_4[[s_4]]
          s_4 -->|0..9| s_5[[s_5]]
          s_5 -->|0..9| D[...]

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      This diagram has a few problems. Specifically:

      * It goes infinitely, breaking the invariant that \(S\) is finite.
      * All the states on the path beginning with \(s_2\) are equivalent.

      We can simplify the diagram if we allow cycles. That is:

      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_2

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers with cycles.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      To implement this FA, it is obvious that we will now need cyclic control
      flow constructs, compared to the previous ones which could be implemented
      with only branching logic.

      An efficient way to specify \(\delta\) for this FA is using a table:

     #+name: trans_table_unsigned_fa
     #+caption: Transition table for the unsigned number FA
     | \(\delta\) | 0       | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | Other   |
     |------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------|
     | \(s_0\)    | \(s_1\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_1\)    | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) |
     | \(s_2\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_e\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) |  \(s_2\)       | \(s_e\) |
      
******** Review Questions

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|a-zA-Z| s_1[[s_1]]
          s_1 -->|a-zA-Z0-9| s_2[[s_2]]
          s_2 -->|a-zA-Z0-9| s_3[[s_3]]
          s_3 -->|a-zA-Z0-9| s_4[[s_4]]
          s_4 -->|a-zA-Z0-9| s_5[[s_5]]
          s_5 -->|a-zA-Z0-9| s_6[[s_6]]
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png]]

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"("| s_1((s_1))
          s_1 -->|")"| s_2[[s_2]]
          s_2 -->|"("| s_1
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png]]
      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pascal_comment.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"{"| s_1((s_1))
          s_1 -->|"c‚ààŒ£"| s_2((s_2))
          s_1 -->|"}"| s_3[[s_3]]
          s_2 -->|"c‚ààŒ£"| s_2((s_2))
          s_2 -->|"}"| s_3
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_pascal_comment.png]]

*** Regular Expressions
    
    + The set of words accepted by a finite automaton, \(F\), forms a language \(L(F)\).
    + An alternative syntax to describe a language is that of the /regular expressions/.

      A language described by an RE is called a /regular language/.

****** Formalizing the notation

       An RE describes a set of string over the characters in some alphabet, \(\Sigma\), augmented with a character \(\epsilon\) that represents the empty string.
       We call the set of strings a /language/.

       For a given RE, \(r\), we denote the language that it specifies as \(L(r)\).

       An RE is built from three basic forms:

       + Alternation :: The union of two sets of strings, \(R\) and \(S\), denoted \(R | $\), is \(\{ x | x\in R \lor x\inS \}\).
       + Concatenation :: The concatenation of two sets \(R\) and \(S\), denoted \(RS\), contains all strings formed by prepending an element of \(R\) onto one from \(S\), or \(\{xy |x \in R \land y \in S\}\).
       + Closure :: The Kleene closure of a set \(R\), denoted \(R^*\), is \(\bigcup_{i=0}^{\infty}R^i\). That is, the union of the concatenations of \(R\) with itself, zero or more times.

         + Finite Closure :: For any integer \(i\), the RE \(R^i\) designates one to \(i\) occurrences of \(R\).

           It is equal to an enumeration of the possibilities. E.g \(R^3 = (R|RR|RRR)\).
         + Positive Closure :: The RE \(R^+\) denotes one or more occurrences of \(R\), often written as \(\bigcup_{i=1}^{\infty}R^i\).

           It is equal to \(RR^*\).

      From the three basic operation, we can define the set of REs over an alphabet \(\Sigma\) as follow:

      1. If \(a \in \Sigma\), then \(a\) is also an RE denoting the set containing only \(a\).
      2. If \(r\) and \(s\) are REs, denoting sets \(L(r)\) and \(L(s)\), respectively, then:
         * \(r|s\) is an RE denoting the alternation of \(L(r)\) and \(L(s)\).
         * \(rs\) is an RE denoting the concatenation of \(L(r)\) and \(L(s)\).
         * \(r^*\) is an RE denoting the Kleene closure of \(L(r)\).
      3. \(\epsilon\) is an RE denoting the set containing only the empty string.

      To eliminate ambiguity, parenthesis have the highest precedence followed by closure, concatenation and alternation, in that order.

      As an abbreviation, ranges of character can be specified surrounded with square brackets and with an ellipsis in the middle.
      For example, \([0\ldots9] = (0|1|2|3|4|5|6|7|8|9)\).

******** Review Questions

         1. \(
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) )
            (
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )
            )
            \)

          #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pli_strings.png
          flowchart LR
              A[ ] --> s_0((s_0))

              s_0 -->|"''"| s_1((s_1))
              s_1 -->|"c‚ààŒ£"| s_1
              s_1 -->|"''"| s_2[[s_2]]
              s_2 -->|"''"| s_1
          #+end_src

          #+RESULTS:
          [[file:assets/images/autogenerated/transition_diagram_pli_strings.png]]

          \( "(\Sigma|"")" \) where \(\Sigma\) represents any character in the alphabet in the language.

**** From Regular Expression To Scanner
     
******* Non Deterministic Finite Automata

        + \(\epsilon\)-transition :: A transition on the empty string \(\epsilon\), that does not advance the input.

        We can use transitions on \(\epsilon\) to combine FAs.

        Assume that we have an FA for RE /m/ and /n/:

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_m_and_n_separated.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|m| s_1[[s_1]]

            B[ ] --> s_2((s_0))
            s_2 -->|n| s_3[[s_1]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_m_and_n_separated.png]]

        We can combine them as /mn/ by introducing an \(\epsilon\)-transition
        between the two, renumbering the states and using /n/'s accepting state
        as the accepting state for the new FA.
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_m_and_n_epsilon_transition.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|m| s_1((s_1))
            s_1 -->|"ùúñ"| s_2((s_2))
            s_2 -->|n| s_3[[s_3]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_m_and_n_epsilon_transition.png]]

        The \(\epsilon\)-transition could be simplified away, removing the s_2 state.

        Now consider the FAs for the languages \(a^*\), \(ab\) and their
        combination trough \(\epsilon\)-transition to form an FA for the
        language \(a^*ab\):

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_astar_ab.png
        flowchart LR
            A[ ] --> s_0[[s_0]]
            s_0 -->|a| s_0

            B[ ] --> s_2((s_0))
            s_2 -->|a| s_3((s_1))
            s_3 -->|b| s_4[[s_2]]

            C[ ] --> s_5((s_0))
            s_5 -->|a| s_5
            s_5 -->|"ùúñ"| s_6((s_1))
            s_6 -->|a| s_7((s_2))
            s_7 -->|b| s_8[[s_3]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_astar_ab.png]]
        

        Suppose that we input /a/ to the combined FA. The first state, s_0, has
        now two possible transitions instead of one:
           * \(s_0 \overset{a}{\rightarrow} s_0\)
           * \(s_0 \overset{\epsilon}{\rightarrow} s_1\)

        Both of those transitions are right, depending on the input string.
        For example, the first allows us to accept /aab/ and the second allows us to accept /ab/.

        An FA with a state with multiple transitions, such as the above, is
        called a /nondeterministic finite automata/.
        FA which are formed by single-transition states only is called a /deterministic finite automata/.

        Historically, two main models of computation for an NFA are given:

        1. Each time a nondeterministic transition is to be made, the NFA
           chooses the transition that leads to an accepting state for the input
           string. In essence, the NFA guesses the correct transition at each
           point.
        2. Each time the NFA must make a nondeterministic choice, the NFA clones
           itself to pursue each possible transition. In this model the NFA
           pursues all path concurrently.

           At any point, we call the specific set of states in which the NFA is
           active its /Configuration/. A string is accepted when the NFA reaches
           a configuration where the input is exhausted and at least one of the
           clones has reached an accepting state.

******** Equivalence of NFAs and DFAs

         A DFA is a special case of an NFA.
         Hence, an NFA is at least as powerful as a DFA.

         Any NFA can be simulated by a DFA. The intuition is the following:

         Consider an NFA. Under the second model at each state the NFA has a
         finite set of clones. The number of these possible configuration is
         bounded; for each state, the configuration either includes on or more
         clones or it doesn't.

         Thus, an NFA with n state produces at most \(\left| \Sigma \right|^n\) configurations.

         To simulate this behavior, we need a DFA with a state for each configuration.
         While the DFA may have exponentially more states, its set is finite.
         Furthermore, the DFA still makes one transition per input symbol.

         For example, we can construct a DFA for \(a^*ab\):

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_astar_ab_dfa.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|a| s_1((s_1))
            s_1 -->|a| s_1
            s_1 -->|b| s_2[[s_2]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_astar_ab_dfa.png]]

******* Regular Expression to NFA: Thompson's Construction

        + Builds an NFA from an RE.
        + Has a template for a single letter RE and a template transformation for each of the basic RE operators.
          
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_single_lettter.png
        flowchart LR
            A[ ] --> s_i((s_i))
            s_i -->|a| s_j[[s_j]]
        #+end_src

        #+caption: Single letter NFA for a
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_single_lettter.png]]

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_catenation_ab.png
        flowchart LR
            A[ ] --> s_i((s_i))
            s_i -->|a| s_j((s_j))
            s_j -->|"ùúñ"| s_k((s_k))
            s_k -->|b| s_l[[s_l]]
        #+end_src

        #+caption: NFA for the catenation of the single letter NFAs a and b
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_catenation_ab.png]]
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_alternation_a_b.png
        flowchart LR
            A[ ] --> s_m((s_m))
            s_m -->|"ùúñ"| s_i((s_i))
            s_m -->|"ùúñ"| s_k((s_k))
            s_i -->|a| s_j((s_j))
            s_k -->|b| s_l((s_l))
            s_j -->|"ùúñ"| s_n[[s_n]]
            s_l -->|"ùúñ"| s_n
        #+end_src

        #+caption: NFA for the alternation of the single letter NFAs a and b
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_alternation_a_b.png]]
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_closure_a.png
        flowchart LR
            A[ ] --> s_p((s_p))
            s_p -->|"ùúñ"| s_i((s_i))
            s_i -->|a| s_j((s_j))
            s_j -->|"ùúñ"| s_i
            s_j -->|"ùúñ"| s_q[[s_q]]
            s_p -->|"ùúñ"| s_q
        #+end_src

        #+caption: NFA for the closure of the single letter NFA a
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_closure_a.png]]
        
        To apply:
         1. A single letter NFA is built for each character in the RE.
         2. Following the precedence of operators, the transformation for
            alternation, concatenation and closure are applied to the collection
            of NFAs that was built.


         For example, for \(a(b|c)^*\) would first construct an NFA for each of \(a\), \(b\) and \(c\).
         Then build the alternated expression \(b|c\) from those.
         Following, closure has higher precedence than concatenation, so that \((b|c)^*\) would be derived.
         Finally, the NFA for \(a\) and \((b|c)^*\) are concatenated.

       Each generated NFA has specific properties:

         + Only one starting and accepting state
         + No transition, other than the initial transition, enters the starting state.
         + No transition leaves the accepting state
         + An \(\epsilon\)-transition always connects two states that were the
           start state and accepting state of the NFAs for some components of
           the REs.
         + Each state has at most two entering and two exiting \(\epsilon\)-moves.
         + Each state has at most one entering and one exiting move on a symbol in the alphabet.

******* NFA to DFA: The Subset Construction
 
        + Builds a DFA from an NFA

        Subset construction takes an NFA, \((N, \Sigma, \delta_N, n_0, N_A)\),
        and produces a DFA \((D, \Sigma, \delta_D, d_0, N_A)\).

        The new states and transition function are derived from from those of the original NFA.
        The following pseudocode shows a way to do the derivation:

        #+caption: Pseudocode for the Subset Construction algorithm
        #+begin_center
        q_0 <- œµ-closure([n_0]);
        Q <- q_0;
        Worklist <- [q_0];

        while (Worklist ‚â† ‚àÖ) do
          remove q from Worklist;

          for each character c‚ààùö∫ do
            t <- œµ-closure(Delta(q, c));
            T[q,c] <- t;
            if t‚àâQ then
              add t to Q and to Worklist;
          end;
        end;
        #+end_center
 
        + Start from the set q_0, containing n_0 and all states that are reachable from it by paths that only contains \(\epsilon\)-transitions.

          This set is the \(\epsilon\)-closure of n_0.

          \(\epsilon\)-closure takes a set, \(S\), of NFA states and returns a
          set of NFA states constructed from \(S\).

          Each state \(s_i \in S\) is examined and any state that is reachable
          from \(s_i\) by following one or more \(\epsilon\)-transition is added
          to \(S\).
        + Initialize a set Q whose elements are each a subset of N. When the
          algorithm ends, each element of Q represents a state in the resulting
          DFA.

          Initially, Q contains q_0.
          
          The elements of Q are built by following transitions on the NFA, such
          that they represent a valid configuration for the NFA.
        + Each iteration, a set q is removed from the Worklist.

          Each q represents a valid configuration. The configuration is then
          searched by applying the transition function for each character in the
          alphabet and expanding the set with \(\epsilon\)-closure.

          All generated transitions are added to a table T.
          Any newly generated configuration is the added to Q and the Worklist.
        + At the end of the computation, Q contains all the valid configuration
          of the NFA and T holds all of the transition between them.
        + The DFA is then built from Q and T.

          * For each \(\q_i \in Q\) a state \(d_i \in D\) is created.
            If \(q_i\) is an accepting state in the NFA, then the resulting state is an accepting state of the DFA.
          * The transition function is built from T, respecting the mapping from Q to D.
          * The state constructed from \(q_0\) is marked as \(d_0\).
       

******* DFA to minimal DFA: Hopcroft's Algorithm

        + We can minimize the number of states that of an autogenerated DFA as they impact the required amount of space.
        + To minimize the number of states, we need to understand when two states are equivalent such that they produce the same behavior on any input string.

        #+caption: Pseudocode for the Hopcroft's Algorithm
        #+begin_center
        Split(S) {
          for each c‚ààŒ£ do
            if c splits S into s1 and s2
              then return {s1,s2}
          end;

          return S
        }

        T <- { D_A, { D - D_A } };
        P <- ‚àÖ
        while (P ‚â† T) do
          P <- T;
          T <- ‚àÖ;
          for each set p‚ààP do
            T <- T‚à™Split(p);
          end;
       end;
        #+end_center
        
        The algorithm builds a set partition, P, of the DFA state.
        The sets in P group states by behavioral equivalence.

        That is:

        * Two DFA states \(d_i,d_j \in p_s\), being in the same partitioned set, must respect \(d_i \overset{c}{\rightarrow} d_x\), \(d_j \overset{c}{\rightarrow} d_y\) and \(d_x,d_y \in p_t\).
          This must be valid for every input character \(c\).

        Each set in P should be as large as possible as to minimize the DFA.
        To do this, the algorithm starts with rough partition that obeys all constraints but not behavioral equivalence, and the refines it.

        At the start, the partition contains two sets:
          * The set of accepting states.
          * The set of all states that are not accepting states.
            
       The refinement is done by checking each set repeatedly and find the states that have different behaviors on some input string.
       As not all input strings can be examined, the model simulate the behavior of each state for all input characters.

       If the behavior is not the same for a character, the set is split around the character.
        
******* Using a DFA as a recognizer

        To be useful, a scanner must recognizer all syntactic category for a grammar.
        Given an RE for each category, we can form an RE for the whole collection by concatenating all of the REs.

        If this is then run trough the whole process to produce a DFA, then that produces a scanner that recognizes the next word that matches one of the categories.

        At the recognizer level, we have multiple choices for the notion of acceptance.
        The DFA should run over the whole input to recognize the longest word. At that point two cases are available:

        + The DFA ends in an accepting state. This means a word was found and it should be returned.
        + The DFA is not in an accepting state.  This is more complex and spawn two other cases:
          * If the DFA passed to one or more accepting states during the process, it should backtrack to the most recent one and return the recognized word.
          * If no accepting state was met, the no valid word is a prefix of the input and an error should be reported.
            
       Furthermore, an accepting state may represent more than one syntactic
       category. For example, if the recognizer has both keywords and identifier
       their REs may overlap and the recognizer should choose which category it
       is dealing with.

       As a practical matter, the scanner will need to handle those parts of the input stream that do not form a word, such as blank spaces.
       Usually, an RE is added to match blanks and end of line characters, with, usually, an action that invoke the scanner recursively when such characters are met.
        
        
**** Implementing Scanners

****** Table driven scanners
       
       #+caption: A driver for the skeleton of a table-driven scanner
       #+begin_center
       NextWord()
         state <- s0;
         lexeme <- " ";
         clear stack;
         push(bad);

         while (state‚â†se) do
           NextChar(char);
           lexeme <- lexeme + char;
           if state‚ààS_A
             then clear stack;
           push(state);

           cat <- CharCat[char];
           state <- Œ¥[state.car];
         end;

         while(state‚àâ S_A and state ‚â† bad) do
           state <- pop();
           truncate lexeme;
           RollBack();
        end;

        if state‚ààS_A
          then return Type[state];
          else return invalid
       #+end_center
      
       #+name: table:classifier_register_scanner
       #+caption: The Classifier Table for [0..9]+
       | r        | 0,1,2,...,9 | EOF   | Other |
       |----------+-------------+-------+-------|
       | Register | Digit       | Other | Other |
       
       #+name: table:transition_register_scanner
       #+caption: The Transition table,Œ¥, for [0..9]+
       |    | Register | Digit | Other |
       |----+----------+-------+-------|
       | s0 | s1       | se    | se    |
       | s1 | se       | s2    | se    |
       | s2 | e        | s2    | se    |
       | se | se       | se    | se    |
       
       #+caption: The Token Type table for [0..9]+
       | s0      | s1      | s2       | se      |
       |---------+---------+----------+---------|
       | invalid | invalid | register | invalid |
       
      
       #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_register_table_driven_scanner.png
       flowchart LR

        A[ ] --> s_0((s_0))
        s_0 -->|r| s_1((s_1))
        s_1 -->|"0..9"| s_2[[s_2]]
        s_2 -->|"0..9"| s_2
       #+end_src

       #+RESULTS:
       [[file:assets/images/autogenerated/transition_diagram_register_table_driven_scanner.png]]
 
       + Uses a skeleton scanner whose behavior is customized by a series of table.

         Divided into four sections:
           * Initializations.
           * Scanning loop that models the behavior of a DFA.

             Repeats two basic actions:
              * Read a character
              * Simulate a transition

             Stops if the error state is reached.
           * A roll back loop in case the DFA overshoot.
           * A final section that interprets the results.


      Two tables are used to drive the scanner.

      The first one, [[table:classifier_register_scanner]], classifies a character into a category while the second one, [[table:transition_register_scanner]], acts as the transition function.
      Categorizing first allow the use of a compressed transition table. With a bigger character set the implementation of [[table:classifier_register_scanner]] may need to become more complicated.

******** Avoiding excessive rollback

         Consider the RE \(ab|(ab)^*c\).
         If the input "ababababc" were used, a scanner would read all the characters and return the recognized string.
         If we were, instead, to remove the last character from that input, the scanner must scan all characters and the roll back to the prefix "ab".
         In the next iteration, the same would happen and so on until the last pair.

         In this worst case, it has a quadratic complexity.

         A change that can be done to avoid this pathological behavior is to record a backlog of dead-end transitions that were encountered in previous iterations.
         This new version is called a /maximal munch scanner/.

         Most programming languages have simple microsyntaxes that do not allow
         the pathological behavior in the first place but, for those who do, a
         series of optimization should be made to use a table scanner.

         Changing the used table changes the language that is recognized by the scanner.

******** Generating the transition and Classifier Tables

         Given a DFA, it is straightforward to generate the tables.

         The initial transition table has one column for every character in the
         input alphabet and one row for each state in the DFA.

         For each state, the out-bound transitions are checked and the rows filled with the appropriate states.
         The generator then collapses identical columns into a single interface, constructor the character classifier in the meantime.

         A minified DFA cannot have repeating row and thus compressions is not an issue.
       
****** Direct coded scanners
        
       Table-driven scanners have an overhead due to the table lookups.
       While the lookups are *O*(1), they impose constant overheads that can be avoided.
       In particular, two address computations and two load operations are executed for each character.

       To remove the overhead, we need to replace the main loop of the scanner.

       Instead of representing the current state of the DFA and the transition
       table, a direct-coded scanner implicitly represents the transitions by
       specialized code for each state, passing from state-fragment to
       state-fragment to emulate the DFA behavior.

       While this means that the scanner is able to represent a single DFA, it is possible to generate the fragments from a specification.

****** Hand coded scanners
       
       Surveys shows that most compilers use hand-coded scanners.

       For example, while the /flex/ scanner generator was created for the /gcc/
       project, /gcc 4.0/ uses hand-coded scanners in several of its front-ends.

       The advantage of hand-coded scanners is that they can reduce the overhead of interfacing with the rest of the system.

******** Buffering the input stream

         While character-by-character IO leads to clean algorithmic formulations, the overhead of a procedure call for each character is significant.

         The cost of using buffer instead of a per-character analysis allows for a large initial overhead to access the buffer and a small per-character cost.
         A buffer and pointer scheme amortizes the cost of reading over many single character fetches.

         Furthermore, the cost of rollbacking is diminished, as the scanner only needs to decrement a pointer to return to a previous state.

******** Generating Lexemes

         Hand-coded scanners can optimize situations in which the generation of the lexeme is not a direct representation of its string.

         For example, a string representing a number may need to be converted to an actual number. A way to do this is to call a routine over the string representing it.
         Nonetheless, it is possible to optimize this process by keeping count of the integer when a digit is encountered and multiplying it by 10 and the digit during state transitions.

         In other cases the representation of the lexeme is redundant, for
         example for punctuation. Generated scanner, while they allow for
         actions to be performed on the whole lexeme, do not allow state-based
         action during a transition, accumulating the whole lexeme even when it
         is not needed.

         In an hand-coded scanners these optimizations can take place, improving compile times.

******** Handling Keywords
         
         In generated scanners, the machinery needs to consume memory for an hash table to recognize keywords.
         In an hand-coded scanner, this process can be optimized to avoid a table lookup for each identifier.
         
         
**** Advanced topics

****** DFA to RE (Kleene Construction)

       Consider the transition diagram for a DFA as a graph with labeled edges.
       The problem of deriving an RE that describe the language accepted by the DFA corresponds to a path problem over the diagram.

       The set of string in the language is the set of edge labels for every path from the initial state to an accepting state.
       For any diagram that is cyclic, such a set of strings is infinite. Fortunately, the Kleene closure takes care of that.
