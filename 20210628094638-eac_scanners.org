#+title: EaC:Scanners
#+roam_tags: EaC compilers books lexer lexing scanning scanner
#+roam_source: [[https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0][Engineering A Compiler]]


+ Aggregates sequences of characters into a sequence of words that are /parts of speech/ in the language.
  * First stage the compiler does to understand the input program.
  * Only pass in the compiler which touches all characters.
  * While scanners can be generated, most compilers use hand-crafter ones to improve performance.
    
+ Syntactic category :: A classification of words according to their grammatical usage.
+ Microsyntax :: The lexical structure of a language.
  
The scanner reads an input streams and produces a stream of words labeled by their syntactic category.
To achieve this construction, the scanner applies the lexical rules of the language, its /microsyntax/.

    * Most programming languages have a simple microsyntax where characters are
      collected into words and blanks and punctuation marks signal the
      separation between words.
    * Most programming languages have a series of 'reserved keywords' which
      match the rule for an identifier. The scanner categorizes them into their
      own category by either using a lookup table or by encoding this
      distinction into the mycrosyntax of the language.

+ Scanners can be implemented to require \(\bm{O}(1)\) time per character, and, hence, \(\bm{O}(n)\) time proportional to the characters in the input stream.

*** Recognizing Words

    A recognizer can be seen, mathematically, as a finite automata.

    + Finite Automaton :: A formalism for recognizers that has a finite set of states, an alphabet, a transition function, a start state and one or more accepting states.
      + Transition Diagram :: Visualization of a finite automata.

      A finite automaton is a five tuple \(\left(S, \Sigma, \delta, s_0, S_A \right)\) where
      
      * \(S\) is the finite set of states in the recognizer, along with an error state \(S_e\).
      * \(\Sigma\) is the finite alphabet used by the recognizer. Typically, \(\Sigma\) is the union of the edge labels in the transition diagram.
      * \(\delta(s, c)\) is the recognizer's transition function. It maps each
        state \(s\in S\) and each character \(c \in \Sigma\) into some next
        state. In state \(s_i\) with input character \(c\), the finite automata
        takes the transition \(s_i \overset{c}{\rightarrow} \delta(s_i, c)\).
      * \(S_A\) is the set of accepting states, \(S_A \subseteq S\).
        
      For example, we can describe a recognizer for the words /while/, /not/ and /now/, as follows:

      #+name: while_new_not_finite_automaton
      #+caption: A finite automaton recognizing the words while, not and now.
      #+begin_latex
        \begin{align*}
          S &= \left{ s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_10, s_e \right} \\[5pt]
          \Sigma &= \left{ e, h, i, l, n, o, t, w \right} \\[5pt]
          \delta &= \begin{Bmatrix}s_0 \overset{n}{\rightarrow}s_1&s_0 \overset{w}{\rightarrow}s_6&s_1 \overset{e}{\rightarrow}s_2&s_1\overset{o}{\rightarrow}s_4&s_2 \overset{w}{\rightarrow}s_3\\s_4 \overset{t}{\rightarrow}s_5&s_6 \overset{h}{\rightarrow}s_7&s_7 \overset{i}{\rightarrow}s_8&s_8\overset{l}{\rightarrow}s_9&s_9 \overset{e}{\rightarrow}s_{10}\end{Bmatrix} \\[5pt]
          s_0 &= s_0 \\[5pt]
          S_A &= \left{ s_3, s_5, s_{10} \right}
        \end{align*}
      #+end_latex

     
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_while_new_not.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|n| s_1((s_1))
          s_0 -->|w| s_6((s_6))

          s_1 -->|e| s_2((s_2))
          s_1 -->|o| s_4((s_4))

          s_2 -->|w| s_3[[s_3]]

          s_4 -->|t| s_5[[s_5]]
 
          s_6 -->|h| s_7((s_7))
          s_7 -->|i| s_8((s_8))
          s_8 -->|l| s_9((s_9))
          s_9 -->|e| s_10[[ s_10 ]]
      #+end_src

      #+caption: Transition Diagram for [[while_new_not_finite_automaton]].
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_while_new_not.png]]

      Implicitly, all other combination of states, \(s_i\) and character, \(c\) we define the transition to the error state \(\delta(s_i, c) = s_e\).
      
      An FA accepts a string if and only if the sequence of characters leave the FA in an accepting state when the whole input is consumed.
      Formally, if the string \(x\) is composed of the characters \(x_1x_2x_3\ldotsx_n\), then the FA \(\left(S, \Sigma, \delta, s_0, S_A \right)\) accepts \(x\) iff \(\delta(\delta(\ldots\delta(\delta(\delta(s_0, x_1), x_2, x_3)\ldots,x_{n_1}), x_n) \in S_A\).

      The other possibilities is that the FA encounters an error. That is, it transitions to the error state or it consumes the input without finishing in an accepting state.

****** Recognizing unsigned numbers

       We can build a recognizer for an unsigned number, that is either 0 or a sequence of digits not starting with zero, as follows:

       
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_3[[s_3]]
          s_3 -->|0..9| s_4[[s_4]]
          s_4 -->|0..9| s_5[[s_5]]
          s_5 -->|0..9| D[...]

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      This diagram has a few problems. Specifically:

      * It goes infinitely, breaking the invariant that \(S\) is finite.
      * All the states on the path beginning with \(s_2\) are equivalent.

      We can simplify the diagram if we allow cycles. That is:

      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_2

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers with cycles.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      To implement this FA, it is obvious that we will now need cyclic control
      flow constructs, compared to the previous ones which could be implemented
      with only branching logic.

      An efficient way to specify \(\delta\) for this FA is using a table:

     #+name: trans_table_unsigned_fa
     #+caption: Transition table for the unsigned number FA
     | \(\delta\) | 0       | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | Other   |
     |------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------|
     | \(s_0\)    | \(s_1\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_1\)    | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) |
     | \(s_2\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_e\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) |  \(s_2\)       | \(s_e\) |
      
******** Review Questions

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|a-zA-Z| s_1[[s_1]]
          s_1 -->|a-zA-Z0-9| s_2[[s_2]]
          s_2 -->|a-zA-Z0-9| s_3[[s_3]]
          s_3 -->|a-zA-Z0-9| s_4[[s_4]]
          s_4 -->|a-zA-Z0-9| s_5[[s_5]]
          s_5 -->|a-zA-Z0-9| s_6[[s_6]]
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png]]

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"("| s_1((s_1))
          s_1 -->|")"| s_2[[s_2]]
          s_2 -->|"("| s_1
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png]]
      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pascal_comment.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"{"| s_1((s_1))
          s_1 -->|"c∈Σ"| s_2((s_2))
          s_1 -->|"}"| s_3[[s_3]]
          s_2 -->|"c∈Σ"| s_2((s_2))
          s_2 -->|"}"| s_3
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_pascal_comment.png]]

*** Regular Expressions
    
    + The set of words accepted by a finite automaton, \(F\), forms a language \(L(F)\).
    + An alternative syntax to describe a language is that of the /regular expressions/.

      A language described by an RE is called a /regular language/.

****** Formalizing the notation

       An RE describes a set of string over the characters in some alphabet, \(\Sigma\), augmented with a character \(\epsilon\) that represents the empty string.
       We call the set of strings a /language/.

       For a given RE, \(r\), we denote the language that it specifies as \(L(r)\).

       An RE is built from three basic forms:

       + Alternation :: The union of two sets of strings, \(R\) and \(S\), denoted \(R | $\), is \(\{ x | x\in R \lor x\inS \}\).
       + Concatenation :: The concatenation of two sets \(R\) and \(S\), denoted \(RS\), contains all strings formed by prepending an element of \(R\) onto one from \(S\), or \(\{xy |x \in R \land y \in S\}\).
       + Closure :: The Kleene closure of a set \(R\), denoted \(R^*\), is \(\bigcup_{i=0}^{\infty}R^i\). That is, the union of the concatenations of \(R\) with itself, zero or more times.

         + Finite Closure :: For any integer \(i\), the RE \(R^i\) designates one to \(i\) occurrences of \(R\).

           It is equal to an enumeration of the possibilities. E.g \(R^3 = (R|RR|RRR)\).
         + Positive Closure :: The RE \(R^+\) denotes one or more occurrences of \(R\), often written as \(\bigcup_{i=1}^{\infty}R^i\).

           It is equal to \(RR^*\).

      From the three basic operation, we can define the set of REs over an alphabet \(\Sigma\) as follow:

      1. If \(a \in \Sigma\), then \(a\) is also an RE denoting the set containing only \(a\).
      2. If \(r\) and \(s\) are REs, denoting sets \(L(r)\) and \(L(s)\), respectively, then:
         * \(r|s\) is an RE denoting the alternation of \(L(r)\) and \(L(s)\).
         * \(rs\) is an RE denoting the concatenation of \(L(r)\) and \(L(s)\).
         * \(r^*\) is an RE denoting the Kleene closure of \(L(r)\).
      3. \(\epsilon\) is an RE denoting the set containing only the empty string.

      To eliminate ambiguity, parenthesis have the highest precedence followed by closure, concatenation and alternation, in that order.

      As an abbreviation, ranges of character can be specified surrounded with square brackets and with an ellipsis in the middle.
      For example, \([0\ldots9] = (0|1|2|3|4|5|6|7|8|9)\).

******** Review Questions

         1. \(
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) )
            (
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )
            )
            \)

          #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pli_strings.png
          flowchart LR
              A[ ] --> s_0((s_0))

              s_0 -->|"''"| s_1((s_1))
              s_1 -->|"c∈Σ"| s_1
              s_1 -->|"''"| s_2[[s_2]]
              s_2 -->|"''"| s_1
          #+end_src

          #+RESULTS:
          [[file:assets/images/autogenerated/transition_diagram_pli_strings.png]]

          \( "(\Sigma|"")" \) where \(\Sigma\) represents any character in the alphabet in the language.

**** From Regular Expression To Scanner

     
