#+title: EaC:Scanners
#+roam_tags: EaC compilers books lexer lexing scanning scanner finite-automata nondeterministic-finite-automata regex nondeterministic-finite-automata deterministic-finite-automata thompson-construction subset-construction hopcroft-algorithm
#+roam_source: [[https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0][Engineering A Compiler]]


+ Aggregates sequences of characters into a sequence of words that are /parts of speech/ in the language.
  * First stage the compiler does to understand the input program.
  * Only pass in the compiler which touches all characters.
  * While scanners can be generated, most compilers use hand-crafter ones to improve performance.
    
+ Syntactic category :: A classification of words according to their grammatical usage.
+ Microsyntax :: The lexical structure of a language.
  
The scanner reads an input streams and produces a stream of words labeled by their syntactic category.
To achieve this construction, the scanner applies the lexical rules of the language, its /microsyntax/.

    * Most programming languages have a simple microsyntax where characters are
      collected into words and blanks and punctuation marks signal the
      separation between words.
    * Most programming languages have a series of 'reserved keywords' which
      match the rule for an identifier. The scanner categorizes them into their
      own category by either using a lookup table or by encoding this
      distinction into the mycrosyntax of the language.

+ Scanners can be implemented to require \(\bm{O}(1)\) time per character, and, hence, \(\bm{O}(n)\) time proportional to the characters in the input stream.

*** Recognizing Words

    A recognizer can be seen, mathematically, as a finite automata.

    + Finite Automaton :: A formalism for recognizers that has a finite set of states, an alphabet, a transition function, a start state and one or more accepting states.
      + Transition Diagram :: Visualization of a finite automata.

      A finite automaton is a five tuple \(\left(S, \Sigma, \delta, s_0, S_A \right)\) where
      
      * \(S\) is the finite set of states in the recognizer, along with an error state \(S_e\).
      * \(\Sigma\) is the finite alphabet used by the recognizer. Typically, \(\Sigma\) is the union of the edge labels in the transition diagram.
      * \(\delta(s, c)\) is the recognizer's transition function. It maps each
        state \(s\in S\) and each character \(c \in \Sigma\) into some next
        state. In state \(s_i\) with input character \(c\), the finite automata
        takes the transition \(s_i \overset{c}{\rightarrow} \delta(s_i, c)\).
      * \(S_A\) is the set of accepting states, \(S_A \subseteq S\).
        
      For example, we can describe a recognizer for the words /while/, /not/ and /now/, as follows:

      #+name: while_new_not_finite_automaton
      #+caption: A finite automaton recognizing the words while, not and now.
      #+begin_latex
        \begin{align*}
          S &= \left{ s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_10, s_e \right} \\[5pt]
          \Sigma &= \left{ e, h, i, l, n, o, t, w \right} \\[5pt]
          \delta &= \begin{Bmatrix}s_0 \overset{n}{\rightarrow}s_1&s_0 \overset{w}{\rightarrow}s_6&s_1 \overset{e}{\rightarrow}s_2&s_1\overset{o}{\rightarrow}s_4&s_2 \overset{w}{\rightarrow}s_3\\s_4 \overset{t}{\rightarrow}s_5&s_6 \overset{h}{\rightarrow}s_7&s_7 \overset{i}{\rightarrow}s_8&s_8\overset{l}{\rightarrow}s_9&s_9 \overset{e}{\rightarrow}s_{10}\end{Bmatrix} \\[5pt]
          s_0 &= s_0 \\[5pt]
          S_A &= \left{ s_3, s_5, s_{10} \right}
        \end{align*}
      #+end_latex

     
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_while_new_not.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|n| s_1((s_1))
          s_0 -->|w| s_6((s_6))

          s_1 -->|e| s_2((s_2))
          s_1 -->|o| s_4((s_4))

          s_2 -->|w| s_3[[s_3]]

          s_4 -->|t| s_5[[s_5]]
 
          s_6 -->|h| s_7((s_7))
          s_7 -->|i| s_8((s_8))
          s_8 -->|l| s_9((s_9))
          s_9 -->|e| s_10[[ s_10 ]]
      #+end_src

      #+caption: Transition Diagram for [[while_new_not_finite_automaton]].
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_while_new_not.png]]

      Implicitly, all other combination of states, \(s_i\) and character, \(c\) we define the transition to the error state \(\delta(s_i, c) = s_e\).
      
      An FA accepts a string if and only if the sequence of characters leave the FA in an accepting state when the whole input is consumed.
      Formally, if the string \(x\) is composed of the characters \(x_1x_2x_3\ldotsx_n\), then the FA \(\left(S, \Sigma, \delta, s_0, S_A \right)\) accepts \(x\) iff \(\delta(\delta(\ldots\delta(\delta(\delta(s_0, x_1), x_2, x_3)\ldots,x_{n_1}), x_n) \in S_A\).

      The other possibilities is that the FA encounters an error. That is, it transitions to the error state or it consumes the input without finishing in an accepting state.

****** Recognizing unsigned numbers

       We can build a recognizer for an unsigned number, that is either 0 or a sequence of digits not starting with zero, as follows:

       
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_3[[s_3]]
          s_3 -->|0..9| s_4[[s_4]]
          s_4 -->|0..9| s_5[[s_5]]
          s_5 -->|0..9| D[...]

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      This diagram has a few problems. Specifically:

      * It goes infinitely, breaking the invariant that \(S\) is finite.
      * All the states on the path beginning with \(s_2\) are equivalent.

      We can simplify the diagram if we allow cycles. That is:

      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|1..9| s_2[[s_2]]

          s_2 -->|0..9| s_2

          s_0 -->|0| s_1[[s_1]]
      #+end_src

      #+caption: Transition Diagram for recognizing unsigned numbers with cycles.
      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_unsigned_number_not_cyclic.png]]

      To implement this FA, it is obvious that we will now need cyclic control
      flow constructs, compared to the previous ones which could be implemented
      with only branching logic.

      An efficient way to specify \(\delta\) for this FA is using a table:

     #+name: trans_table_unsigned_fa
     #+caption: Transition table for the unsigned number FA
     | \(\delta\) | 0       | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | Other   |
     |------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------|
     | \(s_0\)    | \(s_1\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_1\)    | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) | \(s_e\) |
     | \(s_2\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_e\) |
     | \(s_e\)    | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) | \(s_2\) |  \(s_2\)       | \(s_e\) |
      
******** Review Questions

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|a-zA-Z| s_1[[s_1]]
          s_1 -->|a-zA-Z0-9| s_2[[s_2]]
          s_2 -->|a-zA-Z0-9| s_3[[s_3]]
          s_3 -->|a-zA-Z0-9| s_4[[s_4]]
          s_4 -->|a-zA-Z0-9| s_5[[s_5]]
          s_5 -->|a-zA-Z0-9| s_6[[s_6]]
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_identifier_alpha_0-5_alphanum.png]]

      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"("| s_1((s_1))
          s_1 -->|")"| s_2[[s_2]]
          s_2 -->|"("| s_1
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_one_or_more_parehtesis_pair.png]]
      
      #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pascal_comment.png
      flowchart LR
          A[ ] --> s_0((s_0))

          s_0 -->|"{"| s_1((s_1))
          s_1 -->|"c∈Σ"| s_2((s_2))
          s_1 -->|"}"| s_3[[s_3]]
          s_2 -->|"c∈Σ"| s_2((s_2))
          s_2 -->|"}"| s_3
      #+end_src

      #+RESULTS:
      [[file:assets/images/autogenerated/transition_diagram_pascal_comment.png]]

*** Regular Expressions
    
    + The set of words accepted by a finite automaton, \(F\), forms a language \(L(F)\).
    + An alternative syntax to describe a language is that of the /regular expressions/.

      A language described by an RE is called a /regular language/.

****** Formalizing the notation

       An RE describes a set of string over the characters in some alphabet, \(\Sigma\), augmented with a character \(\epsilon\) that represents the empty string.
       We call the set of strings a /language/.

       For a given RE, \(r\), we denote the language that it specifies as \(L(r)\).

       An RE is built from three basic forms:

       + Alternation :: The union of two sets of strings, \(R\) and \(S\), denoted \(R | $\), is \(\{ x | x\in R \lor x\inS \}\).
       + Concatenation :: The concatenation of two sets \(R\) and \(S\), denoted \(RS\), contains all strings formed by prepending an element of \(R\) onto one from \(S\), or \(\{xy |x \in R \land y \in S\}\).
       + Closure :: The Kleene closure of a set \(R\), denoted \(R^*\), is \(\bigcup_{i=0}^{\infty}R^i\). That is, the union of the concatenations of \(R\) with itself, zero or more times.

         + Finite Closure :: For any integer \(i\), the RE \(R^i\) designates one to \(i\) occurrences of \(R\).

           It is equal to an enumeration of the possibilities. E.g \(R^3 = (R|RR|RRR)\).
         + Positive Closure :: The RE \(R^+\) denotes one or more occurrences of \(R\), often written as \(\bigcup_{i=1}^{\infty}R^i\).

           It is equal to \(RR^*\).

      From the three basic operation, we can define the set of REs over an alphabet \(\Sigma\) as follow:

      1. If \(a \in \Sigma\), then \(a\) is also an RE denoting the set containing only \(a\).
      2. If \(r\) and \(s\) are REs, denoting sets \(L(r)\) and \(L(s)\), respectively, then:
         * \(r|s\) is an RE denoting the alternation of \(L(r)\) and \(L(s)\).
         * \(rs\) is an RE denoting the concatenation of \(L(r)\) and \(L(s)\).
         * \(r^*\) is an RE denoting the Kleene closure of \(L(r)\).
      3. \(\epsilon\) is an RE denoting the set containing only the empty string.

      To eliminate ambiguity, parenthesis have the highest precedence followed by closure, concatenation and alternation, in that order.

      As an abbreviation, ranges of character can be specified surrounded with square brackets and with an ellipsis in the middle.
      For example, \([0\ldots9] = (0|1|2|3|4|5|6|7|8|9)\).

******** Review Questions

         1. \(
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) )
            (
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ) |
            ( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )( ( A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z ) | ( a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z ) | ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) )
            )
            \)

          #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_pli_strings.png
          flowchart LR
              A[ ] --> s_0((s_0))

              s_0 -->|"''"| s_1((s_1))
              s_1 -->|"c∈Σ"| s_1
              s_1 -->|"''"| s_2[[s_2]]
              s_2 -->|"''"| s_1
          #+end_src

          #+RESULTS:
          [[file:assets/images/autogenerated/transition_diagram_pli_strings.png]]

          \( "(\Sigma|"")" \) where \(\Sigma\) represents any character in the alphabet in the language.

**** From Regular Expression To Scanner
     
******* Non Deterministic Finite Automata

        + \(\epsilon\)-transition :: A transition on the empty string \(\epsilon\), that does not advance the input.

        We can use transitions on \(\epsilon\) to combine FAs.

        Assume that we have an FA for RE /m/ and /n/:

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_m_and_n_separated.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|m| s_1[[s_1]]

            B[ ] --> s_2((s_0))
            s_2 -->|n| s_3[[s_1]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_m_and_n_separated.png]]

        We can combine them as /mn/ by introducing an \(\epsilon\)-transition
        between the two, renumbering the states and using /n/'s accepting state
        as the accepting state for the new FA.
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_m_and_n_epsilon_transition.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|m| s_1((s_1))
            s_1 -->|"𝜖"| s_2((s_2))
            s_2 -->|n| s_3[[s_3]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_m_and_n_epsilon_transition.png]]

        The \(\epsilon\)-transition could be simplified away, removing the s_2 state.

        Now consider the FAs for the languages \(a^*\), \(ab\) and their
        combination trough \(\epsilon\)-transition to form an FA for the
        language \(a^*ab\):

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_astar_ab.png
        flowchart LR
            A[ ] --> s_0[[s_0]]
            s_0 -->|a| s_0

            B[ ] --> s_2((s_0))
            s_2 -->|a| s_3((s_1))
            s_3 -->|b| s_4[[s_2]]

            C[ ] --> s_5((s_0))
            s_5 -->|a| s_5
            s_5 -->|"𝜖"| s_6((s_1))
            s_6 -->|a| s_7((s_2))
            s_7 -->|b| s_8[[s_3]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_astar_ab.png]]
        

        Suppose that we input /a/ to the combined FA. The first state, s_0, has
        now two possible transitions instead of one:
           * \(s_0 \overset{a}{\rightarrow} s_0\)
           * \(s_0 \overset{\epsilon}{\rightarrow} s_1\)

        Both of those transitions are right, depending on the input string.
        For example, the first allows us to accept /aab/ and the second allows us to accept /ab/.

        An FA with a state with multiple transitions, such as the above, is
        called a /nondeterministic finite automata/.
        FA which are formed by single-transition states only is called a /deterministic finite automata/.

        Historically, two main models of computation for an NFA are given:

        1. Each time a nondeterministic transition is to be made, the NFA
           chooses the transition that leads to an accepting state for the input
           string. In essence, the NFA guesses the correct transition at each
           point.
        2. Each time the NFA must make a nondeterministic choice, the NFA clones
           itself to pursue each possible transition. In this model the NFA
           pursues all path concurrently.

           At any point, we call the specific set of states in which the NFA is
           active its /Configuration/. A string is accepted when the NFA reaches
           a configuration where the input is exhausted and at least one of the
           clones has reached an accepting state.

******** Equivalence of NFAs and DFAs

         A DFA is a special case of an NFA.
         Hence, an NFA is at least as powerful as a DFA.

         Any NFA can be simulated by a DFA. The intuition is the following:

         Consider an NFA. Under the second model at each state the NFA has a
         finite set of clones. The number of these possible configuration is
         bounded; for each state, the configuration either includes on or more
         clones or it doesn't.

         Thus, an NFA with n state produces at most \(\left| \Sigma \right|^n\) configurations.

         To simulate this behavior, we need a DFA with a state for each configuration.
         While the DFA may have exponentially more states, its set is finite.
         Furthermore, the DFA still makes one transition per input symbol.

         For example, we can construct a DFA for \(a^*ab\):

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_astar_ab_dfa.png
        flowchart LR
            A[ ] --> s_0((s_0))
            s_0 -->|a| s_1((s_1))
            s_1 -->|a| s_1
            s_1 -->|b| s_2[[s_2]]
        #+end_src

        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_astar_ab_dfa.png]]

******* Regular Expression to NFA: Thompson's Construction

        + Builds an NFA from an RE.
        + Has a template for a single letter RE and a template transformation for each of the basic RE operators.
          
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_single_lettter.png
        flowchart LR
            A[ ] --> s_i((s_i))
            s_i -->|a| s_j[[s_j]]
        #+end_src

        #+caption: Single letter NFA for a
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_single_lettter.png]]

        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_catenation_ab.png
        flowchart LR
            A[ ] --> s_i((s_i))
            s_i -->|a| s_j((s_j))
            s_j -->|"𝜖"| s_k((s_k))
            s_k -->|b| s_l[[s_l]]
        #+end_src

        #+caption: NFA for the catenation of the single letter NFAs a and b
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_catenation_ab.png]]
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_alternation_a_b.png
        flowchart LR
            A[ ] --> s_m((s_m))
            s_m -->|"𝜖"| s_i((s_i))
            s_m -->|"𝜖"| s_k((s_k))
            s_i -->|a| s_j((s_j))
            s_k -->|b| s_l((s_l))
            s_j -->|"𝜖"| s_n[[s_n]]
            s_l -->|"𝜖"| s_n
        #+end_src

        #+caption: NFA for the alternation of the single letter NFAs a and b
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_alternation_a_b.png]]
        
        #+begin_src mermaid :file assets/images/autogenerated/transition_diagram_thompson_closure_a.png
        flowchart LR
            A[ ] --> s_p((s_p))
            s_p -->|"𝜖"| s_i((s_i))
            s_i -->|a| s_j((s_j))
            s_j -->|"𝜖"| s_i
            s_j -->|"𝜖"| s_q[[s_q]]
            s_p -->|"𝜖"| s_q
        #+end_src

        #+caption: NFA for the closure of the single letter NFA a
        #+RESULTS:
        [[file:assets/images/autogenerated/transition_diagram_thompson_closure_a.png]]
        
        To apply:
         1. A single letter NFA is built for each character in the RE.
         2. Following the precedence of operators, the transformation for
            alternation, concatenation and closure are applied to the collection
            of NFAs that was built.


         For example, for \(a(b|c)^*\) would first construct an NFA for each of \(a\), \(b\) and \(c\).
         Then build the alternated expression \(b|c\) from those.
         Following, closure has higher precedence than concatenation, so that \((b|c)^*\) would be derived.
         Finally, the NFA for \(a\) and \((b|c)^*\) are concatenated.

       Each generated NFA has specific properties:

         + Only one starting and accepting state
         + No transition, other than the initial transition, enters the starting state.
         + No transition leaves the accepting state
         + An \(\epsilon\)-transition always connects two states that were the
           start state and accepting state of the NFAs for some components of
           the REs.
         + Each state has at most two entering and two exiting \(\epsilon\)-moves.
         + Each state has at most one entering and one exiting move on a symbol in the alphabet.

******* NFA to DFA: The Subset Construction
 
        + Builds a DFA from an NFA

        Subset construction takes an NFA, \((N, \Sigma, \delta_N, n_0, N_A)\),
        and produces a DFA \((D, \Sigma, \delta_D, d_0, N_A)\).

        The new states and transition function are derived from from those of the original NFA.
        The following pseudocode shows a way to do the derivation:

        #+caption: Pseudocode for the Subset Construction algorithm
        #+begin_center
        q_0 <- ϵ-closure([n_0]);
        Q <- q_0;
        Worklist <- [q_0];

        while (Worklist ≠ ∅) do
          remove q from Worklist;

          for each character c∈𝚺 do
            t <- ϵ-closure(Delta(q, c));
            T[q,c] <- t;
            if t∉Q then
              add t to Q and to Worklist;
          end;
        end;
        #+end_center
 
        + Start from the set q_0, containing n_0 and all states that are reachable from it by paths that only contains \(\epsilon\)-transitions.

          This set is the \(\epsilon\)-closure of n_0.

          \(\epsilon\)-closure takes a set, \(S\), of NFA states and returns a
          set of NFA states constructed from \(S\).

          Each state \(s_i \in S\) is examined and any state that is reachable
          from \(s_i\) by following one or more \(\epsilon\)-transition is added
          to \(S\).
        + Initialize a set Q whose elements are each a subset of N. When the
          algorithm ends, each element of Q represents a state in the resulting
          DFA.

          Initially, Q contains q_0.
          
          The elements of Q are built by following transitions on the NFA, such
          that they represent a valid configuration for the NFA.
        + Each iteration, a set q is removed from the Worklist.

          Each q represents a valid configuration. The configuration is then
          searched by applying the transition function for each character in the
          alphabet and expanding the set with \(\epsilon\)-closure.

          All generated transitions are added to a table T.
          Any newly generated configuration is the added to Q and the Worklist.
        + At the end of the computation, Q contains all the valid configuration
          of the NFA and T holds all of the transition between them.
        + The DFA is then built from Q and T.

          * For each \(\q_i \in Q\) a state \(d_i \in D\) is created.
            If \(q_i\) is an accepting state in the NFA, then the resulting state is an accepting state of the DFA.
          * The transition function is built from T, respecting the mapping from Q to D.
          * The state constructed from \(q_0\) is marked as \(d_0\).
       

******* DFA to minimal DFA: Hopcroft's Algorithm

        + We can minimize the number of states that of an autogenerated DFA as they impact the required amount of space.
        + To minimize the number of states, we need to understand when two states are equivalent such that they produce the same behavior on any input string.

        #+caption: Pseudocode for the Hopcroft's Algorithm
        #+begin_center
        Split(S) {
          for each c∈Σ do
            if c splits S into s1 and s2
              then return {s1,s2}
          end;

          return S
        }

        T <- { D_A, { D - D_A } };
        P <- ∅
        while (P ≠ T) do
          P <- T;
          T <- ∅;
          for each set p∈P do
            T <- T∪Split(p);
          end;
       end;
        #+end_center
        
        The algorithm builds a set partition, P, of the DFA state.
        The sets in P group states by behavioral equivalence.

        That is:

        * Two DFA states \(d_i,d_j \in p_s\), being in the same partitioned set, must respect \(d_i \overset{c}{\rightarrow} d_x\), \(d_j \overset{c}{\rightarrow} d_y\) and \(d_x,d_y \in p_t\).
          This must be valid for every input character \(c\).

        Each set in P should be as large as possible as to minimize the DFA.
        To do this, the algorithm starts with rough partition that obeys all constraints but not behavioral equivalence, and the refines it.

        At the start, the partition contains two sets:
          * The set of accepting states.
          * The set of all states that are not accepting states.
            
       The refinement is done by checking each set repeatedly and find the states that have different behaviors on some input string.
       As not all input strings can be examined, the model simulate the behavior of each state for all input characters.

       If the behavior is not the same for a character, the set is split around the character.
        
        
        
          

          
